#include <cstdio>   // For printf, scanf, fgets
#include <vector>
#include <cstdlib>  // For rand(), srand()
#include <ctime>    // For time()
#include <algorithm> // For max_element
#include <cstring>  // For strlen, strcspn
#include <cctype>   // For isdigit

// Hyperparameters
int EPISODES = 1000;
double EPSILON = 0.1;  // Exploration rate
double ALPHA = 0.1;    // Learning rate
double GAMMA = 0.9;    // Discount factor
int TARGET = 42;       // Default training target
int MAX_STEPS = 5;     // Max operations per episode
const int STATE_BINS = 100;  // Discretize states (0 to 99)

// Actions: Operations to append (no spaces)
std::vector<std::string> ACTIONS = {"+1", "-1", "*2", "/2", "+5", "-3"};

// Q-table: States x Actions
std::vector<std::vector<double>> Q;

// IQ test targets
std::vector<int> IQ_TARGETS = {10, 20, 30, 42, 50};

// Evaluate arithmetic expression (left-to-right, no precedence, integer ops)
int evaluate_expression(const std::string& expr) {
    std::string s = expr;
    int result = 0;
    char op = '+';
    size_t pos = 0;
    while (pos < s.length()) {
        if (std::isdigit(s[pos]) || s[pos] == '-') {
            int num;
            if (sscanf(s.c_str() + pos, "%d", &num) == 1) {
                if (op == '+') result += num;
                else if (op == '-') result -= num;
                else if (op == '*') result *= num;
                else if (op == '/') {
                    if (num != 0) result /= num;
                    else return 0;  // Divide by zero
                }
                while (pos < s.length() && (std::isdigit(s[pos]) || s[pos] == '-')) pos++;
            }
        } else {
            op = s[pos];
            pos++;
        }
    }
    return result;
}

// Simulated URL scraping
std::vector<std::string> scrape_operations_from_url(const char* url) {
    std::vector<std::string> ops = {"+2", "-2", "*3", "/3", "+10"};
    printf("Scraped operations from %s: ", url);
    for (const auto& op : ops) printf("%s ", op.c_str());
    printf("\n");
    return ops;
}

// Initialize Q-table
void initialize_q_table(int num_actions) {
    Q.assign(STATE_BINS, std::vector<double>(num_actions, 0.0));
}

// Help guide
void print_help() {
    printf(
        "=== Code-Generating AI with URL Learning & IQ Test Help Guide ===\n"
        "Purpose:\n"
        "  This AI uses Q-learning to generate arithmetic expressions that evaluate to a target\n"
        "  number (default: 42). It learns by generating code, running it, and improving based\n"
        "  on rewards. It can scrape operations from URLs (simulated) and run an IQ test.\n\n"
        "How It Works:\n"
        "  - Starts with \"0\" and appends operations (e.g., \"+1\", \"*2\") to build a string like \"0+5*2\".\n"
        "  - Evaluates left-to-right (no operator precedence, integer division for /).\n"
        "  - Reward: +10 if result equals target, else penalty based on distance.\n"
        "  - Scrapes URLs for operations (simulated).\n"
        "  - IQ Test: Generates expressions for targets (10, 20, 30, 42, 50) and scores success rate.\n\n"
        "Actions Available:\n"
        "  - Default: +1, -1, *2, /2, +5, -3\n"
        "  - May include URL-scraped operations (e.g., +2, *3).\n\n"
        "Hyperparameters:\n"
        "  - Episodes: Training rounds (default: 1000).\n"
        "  - Learning Rate (0-1, default: 0.1): Update speed.\n"
        "  - Discount Factor (0-1, default: 0.9): Future vs immediate rewards.\n"
        "  - Exploration Rate (0-1, default: 0.1): Random action chance.\n"
        "  - URL: Enter a URL to scrape operations (simulated).\n"
        "  - Command: 'test' for standard test, 'testiq' for IQ test (default: test).\n\n"
        "Usage:\n"
        "  - Type 'help' at prompts for this guide.\n"
        "  - After config, trains and runs chosen test.\n\n"
        "Tips:\n"
        "  - Increase Episodes for better results.\n"
        "  - Evaluation is left-to-right, e.g., 0+5*2 = (0+5)*2 = 10.\n"
        "  - For real URL scraping, use libcurl.\n"
    );
}

// Discretize value
int discretize(int value) {
    return std::min(std::max(value, 0), STATE_BINS - 1);
}

// Choose action: epsilon-greedy
int choose_action(int state) {
    if ((double)std::rand() / RAND_MAX < EPSILON) {
        return std::rand() % ACTIONS.size();  // Explore
    } else {
        auto maxIt = std::max_element(Q[state].begin(), Q[state].end());
        return std::distance(Q[state].begin(), maxIt);  // Exploit
    }
}

// Get reward
double get_reward(int result, int target) {
    if (result == target) return 10.0;
    return -std::abs(static_cast<double>(result - target));
}

// Train
void train() {
    std::srand(static_cast<unsigned>(std::time(0)));
    for (int episode = 0; episode < EPISODES; ++episode) {
        int value = 0;
        std::string code = "0";
        int state = discretize(value);

        for (int step = 0; step < MAX_STEPS; ++step) {
            int action = choose_action(state);
            code += ACTIONS[action];
            int new_value = evaluate_expression(code);
            int new_state = discretize(new_value);
            double reward = get_reward(new_value, TARGET);

            double max_next_q = *std::max_element(Q[new_state].begin(), Q[new_state].end());
            Q[state][action] += ALPHA * (reward + GAMMA * max_next_q - Q[state][action]);

            value = new_value;
            state = new_state;

            if (reward == 10.0) break;
        }
        if ((episode + 1) % 100 == 0) {
            printf("Episode %d: Best Q-values updated\n", episode + 1);
        }
    }
    printf("Training complete!\n");
}

// Standard test
void test(int num_tests = 5) {
    printf("\nStandard Test (Target = %d):\n", TARGET);
    int successes = 0;
    for (int t = 0; t < num_tests; ++t) {
        int value = 0
